# -*- coding: utf-8 -*-

"""
This tool allows to identify Windows machines that MAY be vulnerable to
CVE-2020-0796. It checks for SMB 3.1.1 support and looks for the
SMB2_COMPRESSION_CAPABILITY.

It does NOT attempt to exploit the vulnerability.
"""

from __future__ import print_function

import sys
import argparse
import select
import socket
import struct


__all__ = []
__version__ = "0.1"
__date__ = "2020-03-13"
__prog__ = "cve_2020_0796_check.py"


def main(argv):

    """
    Handles command line options.
    """

    program_shortdesc = "\
This tool allows to identify Windows machines that MAY be vulnerable to\
 CVE-2020-0796.\n"
    program_license = """{}
Example
python cve_2020_0796_check.py --target-ip 192.0.2.1
""".format(program_shortdesc)

    try:
        parser = argparse.ArgumentParser(
            prog=__prog__,
            description=program_license,
            formatter_class=argparse.RawDescriptionHelpFormatter,
        )
        parser.add_argument(
            "--target-ip",
            action="store",
            required=True,
            help="remote endpoint IP address"
        )

        if len(argv) < 2:
            parser.print_help()
            return -1

        args = parser.parse_args()

        socket_ = None
        try:
            socket_ = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except OSError as err:
            print("OS error: {0}".format(err))
            return -1

        may_be_vulnerable = False
        running = False
        smb_request = b'\x00\x00\x00E\xffSMBr\x00\x00\x00\x00\x18S\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xfe\x00\x00\x00\x00\x00"\x00\x02NT LM 0.12\x00\x02SMB 2.002\x00\x02SMB 2.???\x00'
        try:
            socket_.connect((args.target_ip, 445))
            socket_.send(smb_request)
            running = True
        except socket.error as err_mess:
            print("socket.error:", err_mess)
            running = False

        request_sent = False
        while running:
            try:
                read, _, __ = select.select([socket_], [], [], 0.05)
                if read:
                    data = socket_.recv(2048)
                    if data:
                        data_length = len(data)
                        flags = struct.unpack("<I", data[20:24])[0]
                        # Is it a response?
                        if flags & 0x1:
                            if not request_sent:
                                smb_request = b'\x00\x00\x00\xc8\xfeSMB@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xff\xfe\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\x00\x05\x00\x02\x00\x00\x00\x7f\x00\x00\x00\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaap\x00\x00\x00\x03\x00\x00\x00\x02\x02\x10\x02\x00\x03\x02\x03\x11\x03\x00\x00\x01\x00&\x00\x00\x00\x00\x00\x01\x00 \x00\x01\x00\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\x00\x00\x02\x00\x06\x00\x00\x00\x00\x00\x02\x00\x02\x00\x01\x00\x00\x00\x03\x00\x0e\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00'
                                socket_.send(smb_request)
                                request_sent = True
                            else:
                                running = False
                            # Look for SMB 3.1.1 dialect
                            if struct.unpack('>B', data[72])[0] == 0x11 and\
                                struct.unpack('>B', data[73])[0] == 0x03:
                                # Get NegotiateContextOffset
                                offset = struct.unpack('<H', data[128:130])[0]
                                data_remaining = (offset > 0)
                                ctx_index = offset + 4
                                while data_remaining:
                                    ctx_type = struct.unpack('<H', data[ctx_index:ctx_index + 2])[0]
                                    ctx_len = struct.unpack('<H', data[ctx_index + 2:ctx_index + 4])[0]
                                    if ctx_type == 0x03:
                                        # SMB2_COMPRESSION_CAPABILITY
                                        may_be_vulnerable = True
                                    padding = ((ctx_index + ctx_len + 8) - offset + 4) % 8
                                    ctx_index = ctx_index + ctx_len + 8 + padding
                                    data_remaining = (data_length - ctx_index) > 0
            except socket.error as err_mess:
                print("socket.error:", err_mess)
                running = False

            except KeyboardInterrupt:
                running = False

        socket_.shutdown(2)
        socket_.close()

        # Print output
        print("{}\t{}".format(args.target_ip, may_be_vulnerable))

    except Exception as exception:
        print("Unexpected error:", exception)
        return -1

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))
